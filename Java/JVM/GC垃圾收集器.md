## 年轻代
### serial 
- 复制算法
- 单线程
### parNew
- serial 多线程版本
### parallel scavenge
- 关注点是提高吞吐量，而不是关注停顿时间
- XX:+UseAdaptiveSizePolicy
## 老年代
### serial old
- 标记整理
- 单线程
### parallel old
- 标记整理
- 多线程
### CMS
- 标记清除
- 初始标记，标记老年代所有GCroot；并发标记，标记新生代来老年代的、更新老年代对象引用关系等等，并标记为dirty；预清理，处理前一个阶段因为引用关系改变导致没有标记到的存活对象的（只扫描dirty card）；可终止的预处理，；重新标记，stw，可以加入参数-XX:+CMSScavengeBeforeRemark，在重新标记之前，先执行一次ygc，回收掉年轻带的对象无用的对象；并发清理（这个时候可能会有浮动垃圾）；并发重置
- 优点：并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）
- 缺点：对CPU资源非常敏感，无法处理浮动垃圾，标记-清除算法导致的空间碎片

## G1
和CMS相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有CMS的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。

而 G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。

用 -XX:MaxGCPauseMillis=200 指定期望的停顿时间。 G1 不是一个实时收集器，它会尽力满足我们的停顿时间要求，但也不是绝对的，它基于之前垃圾收集的数据统计，估计出在用户指定的停顿时间内能收集多少个区块。

- 初始标记（Initial Marking） 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。
- 并发标记（Concurrent Marking） 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。
- 最终标记（Final Marking） 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。
- 筛选回收（Live Data Counting and Evacuation） 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。